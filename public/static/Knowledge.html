1-1 产品用到的技术 
	ThinkPHP5 编写业务能力 访问数据库 向数据库提供数据
	MySQl     数据库的设计 数据存贮  与业务紧密结合
	微信       支付  学习微信接口
	小程序     直接与用户交互 体验很重要

1-2 课程的流程
	<三端分离>
	服务端
		ThinkPHP5 + MySQL 构建 REST API 接口
	客户端
		向服务端请求数据 完成自身行为编辑
	CMS
		像服务端请求数据 实现发货（常规的增删改查） 发送微信消息（一些特殊功能）

1-6 ThinkPHP5技术特点
	Web框架三大核心知识（路由 控制器 模型）
	验证器 读取器 缓存 全局异常处理
	ORM：模型与关联模型

1-7 微信技术特点
	微信小程序
	微信登陆
	微信支付（预订单 支付 回掉通知处理）
	微信模板消息

1-8 MySQL技术特点
	数据表设计
	数据冗余的合理利用
	事务与锁在订单（库存量）检测中的利用

1-10 面向对象 
	封装 继承 多态

1-11 技术之路
	先有想法 再找工具（语言 框架）
	泛化web 网站 iOS Android 微信（H5 公众号） 小程序

1-12 依赖或者包管理工具
	Composer？ PHP依赖管理工具
	debug？

2-2 单元测试？

2-3 Nginx 反向代理

2-4 ThinkPHP 
	应用项目 + 核心框架（Composer 更新核心代码）

2-5 三端命名
	服务器 Zerg
	小程序 Protoss
	CMS   Terran

2-7 ThinkPHP 层级结构
    controller 控制器
    model 负责业务逻辑
    veder Composer 安装的第三方插件
    thinkphp 核心框架 官方核心类库
    runtime 缓存文件 日志文件
    public web站点的目录 可直接被访问到
    extend 第三方类库

2-8 ThinkPHP 自带的web服务器

3-1 命名空间？

3-8 外键约束？

4-3 独立验证
	Validate
	use think\Validate;
	$data = [
		'name'  => 'wangshuai4444444s',
		'email' => '291qq.com',
	];
	$validate = new Validate([
		'name'  => 'require|max:10',
		'email' => 'email',
	]);

	$result = $validate->batch()->check($data);

	var_dump($validate->geterror());exit;

4-4 验证器
	Valitate
4-5 机构体系详情
	需要被token令牌保护
	    获取某个用户的历史订单信息
	api架构 缓存！
		异常处理
		参数验证->validate->参数是否合法
		控制器 ->不处理业务
		业务层
		    model   (比较简单的业务)
		    service（比较复杂的业务->下单的流程）
		Think DB
		MySQL
4-6 自定义验证规则

5-1 介绍rest之前的重要协议 SOAP
	RESTFuL API 表述性状态转移 实用json描述数据 轻 基于资源 增删改查 都是对资源状态的改变
		  /getmovie/:mid   不允许
		  GET:/movie/:mid  允许
	SOAP 实用xml描述数据 重

5-2 RESTFuL API的最佳实践
	POST    创建
	PUT     更新
	GET     查询
	DELETE  删除

	状态码
		404 资源没找到
		400 参数错误
		200 查询 GET成功
		201 创建 POST状态成功
		202 更新  PUT更新成功
		401 未授权 权限
		403 当前资源被禁止
		500 服务器未知错误 1.代码未知bug  2.服务器错误 不想让客户端知道
		405
		417

	错误码
		用错误码去找具体信息

	统一描述错误码
		错误码
		错误概要信息
		当前产生错误的url

	实用Token令牌来授权 和 验证身份

	版本控制（有版本号）

	测试 和 生产环境分开

	URL要语义明确 望文生义

	最好有一份标准的文档

5-3 如何学习RESTFuL API的设计
	模仿 豆瓣开放API  GitHub开发者API
	切勿盲目的照搬 标准REST

6-1 全局异常处理-----AOP
		异常捕获
		处理异常 记录日志或者修复异常或者返回客户端错误
		抛出异常

6-2 固有的处理异常的思维和流程
	流水账写法

6-3 异常处理分类
	由于用户行为导致的异常 没有通过验证器，没查询到结果--------不需要记录日志，需要返回具体错误信息
	服务器自身异常 代码错误，调用外部接口错误-----------------记录日志，不需要返回异常给客户端

6-4 实现自定义全局异常处理

6-11 AOP 面向切面编程
	是一种思想
	面向对象 -- 封装 多态 继承

7-1 数据库操作三种方式之原生SQl
	构造器
	模型和关联模型 
		1.模型和数据库访问层Db是两个不同的概念
		2.不要因为模型的性能稍差就放弃使用模型
			好的代码第一原则是可读性
			绝大多数的中小型产品远对性能的要求远远没有我们想象的高---高并发另外考虑
			慢真的是因为ORM模型引起的吗----该用in非得用数据库循环查询---大多数都是因为sql质量不高

		3.要用面向对象的思维使用和设计模型
		4.模型自动调用数据库访问抽象层

7-4 查询构造器------查询泛指------query被builder翻译成sql
	原生 不够简洁方便
	查询构造器 封装了对不同数据库的操作
	链式方法 ---- 返回的是 query对象
	find 返回一条数据 一维数组
	select 返回数据集 二唯数组

7-5 查询构造器二
	update 更新
	insert 插入
	delete 删除

	调用了执行方法之后 Db状态才会被清除

7-6 查询构造器三
	where(字段名,表达式,查询条件)-----表达式法
	-----数组法
	-----闭包-----优势：
7-7 开启sql日志记录-------生产环境没有必要开启
	fetcSql 返回sql语句---------1.sql执行的时间等参数没有。2.现在代码里面不太好
	可以自动把sql信息记录到日志里-----1.利于学习  2.分析sql质量

7-8 ORM和模型
	ORM---对象关系映射-----每张表是个对象
	模型---不只是数据库的查询，还包括业务逻辑。
	模型---ORM具体的实现机制----处理比较复杂的业务逻辑---对应多个对象，对应多个表。

7-九 初识模型

7-10 模型总结
	关联模型----主从表
7-11静态调用还是实例对象调用

	查询用静态
		---简洁 
		---model 是个类 对应一张表
		  这个类被实例化之后 对应的是表里面的一条数据
7-12 几种查询动词的总结和与ORM性能的讨论
	get 
	all 
	Db特有的方法
	find 
	select
8-1 banner相关表分析---数据表关系分析
	
8-2 模型关系---定于关联和查询关系

8-3 模型关联---嵌套关联模型
	hasMany 一对多
	belongsTo 一对一

8-4 隐藏模型字段
	代码的合理性
	hidden 隐藏字段
	visible 表示可见字段

8-5在模型内部隐藏字段

8-6图片url资源配置
	扩展配置目录-----extra

8-7读取器的巧妙应用----获取器

8-8自定义模型基类
	解决多张图片表问题

8-9 定义API版本号
	设计代码原则---开闭原则---对扩展是开放的，对修改是封闭的。
	传入version参数判断版本号----(1.修改是造成错误 2.代码变得不简洁 3.对老版本的兼容性)

8-10  专题接口模型分析
	多对多的关系设计原则---通常设计原则：一个theme下面关联很多商品，这些商品构成一个字符串，如果一个theme下面新增一个商品，先查询，再新增。
	数据库冗余

8-12 theme接口验证和重构

8-13 完成theme简要信息接口

8-14 开启路由完整匹配模式

8-15 编写theme详情接口
	要基于资源 还要考虑到客户端的易用性

8-16 数据库冗余的合理利用
	pivot 中心点

	出于查询性能的考虑
	数据一致性和维护困难 -----写入两个地方 更新也得多个地方(容易遗忘)

8-17 REST的合理利用
	REST基于资源
		所有的数据都要返回---保证服务器接口业务逻辑的稳定性

8-18 最近新品接口编写

8-19 适用数据集还是数组
	collection
	select或all操作都返回是根据配置来  配置是array就是array 配置是collection就是collection，只有find这种只查一条的 不管你配成什么 都是数组
8-20 分类列表接口编写
	::all([],'img');
8-21 接口粒度与接口分层
	首页接口三合一
		劣性
			一个小小的改动就要大调整
			APi通用型 要从数据着眼出发 不要从功能
		优点
			http请求次数少，服务器压力小
			粒度过大 复用性不好不够灵活
			粒度过小 客户端调用不方便
	API分层
		底层粒度很小 越往上越大
8-22 分类接口商品编写

9-1 初识Token---意义和作用
	令牌管理用户身份
	客户端携带账号和密码->请求getToken接口----返回账户密码，Token，Auth。
	客户端携带令牌->请求下单接口----对比账户密码，Token，Auth。(Token合法，没有过有效期，符合权限)

9-2 微信身份体系设计 

	小程序(code码) --->  传到微信服务器-----微信服务器收到code码返回openid和session_key(openid用户身份的唯一标识，微信支付能用到openid。session_key用来解密加密信息，加密信息中有Unionid)--->openid存到数据库，生成Token返回客户端。(token和一些用户信息存到缓存中)

	小程序携带令牌--->服务器校验令牌->通过后访问下单接口
		一个用户针对一个小程序 有一个openid
		一个用户针对所有小程序 公众号 服务好 只有一个Unionid

9-3 实现Token身份权限体系
	获取token post 稍微安全  https最安全
9-4 实现Token身份权限体系----获取openid
9-5 实现Token身份权限体系三
9-6 实现Token身份权限体系四
	//令牌 key ： 令牌
    //value : wxResult uid scope
9-7 实现Token身份权限体系五
	//salt 盐 特殊加密信息 特殊字符串
	redis 比文件稍微快一点点
	redis 支持存贮对象 
9-8 API小程序测试工具
9-9 商品详情接口分析和初步编写
	hasMany('关联模型名','外键名','主键名',['模型别名定义']);
	hasOne('关联模型名','外键名','主键名',['模型别名定义'],'join类型');
	belongsTo('关联模型名','外键名','关联表主键名',['模型别名定义'],'join类型');
9-10 路由变量规则与分组

9-11 闭包函数构造查询器

9-12 用户收货地址-----通过令牌获取用户标识

9-13 用户收货地址-----面向对象的方式封装获取UID方法

9-14 用户收货地址-----模型新增和更新

9-14 用户收货地址-----接口测试

10-1 Scope权限作用域的应用
	前置操作
10-2 前置方法
	protected $beforeActionList = [];

10-3 前置方法在address接口中的应用

10-4 下单与支付业务流程 --- 库存量检测
	1.用户选择商品后，像API提交商品的相关信息
	2.API检测库存量
	3.如果库存量有货，插入order表----相当于下单成功，告诉客户端可以支付了
	4.调用支付接口---支付之前在此检测库存量
	5.支付成功再次检测库存量---进行库存量扣除

10-5 下单与支付详细流程

10-6 重构权限控制前置方法

10-7 编写一个复杂的验证器

10-8 下单业务接口模型 一

10-9 下单业务接口模型 二

10-10 订单快照

	我的订单实时查询product表弊病----product信息改变，尤其是价格改变引起很多问题
	写的速度是远远大于读的？？？？

10-11 订单快照的实现
	对象存贮到数据库 MongDb
10-12 订单创建

10-13 一对多新增关系新增操作

10-14 测试订单接口

10-15 在TP5中实现事务
	DB::startTrans();
	DB::commit();
	DB::rollback();
10-17 关于微信支付
	有支付资格
	可以获取 商户号 和 商户密码
10-18 支付的服务端编写
	openid orderid 
10-18 支付的服务端编写二
10-1九 支付的服务端编写三
	1.订单是存在的
	2.订单和当前用户匹配
	3.订单未支付
	4.库存量检测
10-20 支付的服务端编写四
PSR-4 PSR-0 自动加载----use

10-21 
凡是放入到extend下的带有命名空间的类都会被自动加载

10-25 支付的小程序端讲解（含签名的作用讲解） 八 
	客户端向微信的服务器发起请求需要一组参数包括签名
	服务器代码
	微信端小程序

	签名 paySign-----一定程度上防止参数被篡改
	微信服务器把客户端传过来的签名 和 自己重新生成的签名进行 对比

10-26支付的服务端 编写


10-28 支付的服务器端编写（支付结果回调机制） 十一 

10-2九 支付回调通知处理

10-30 支付回调通知处理

10-31 事务与锁防治多次减库存

10-32 接收微信回调
NGROCK 可以把本机作为外网服务器

10-33 测试支付全流程

10-35 tp5中的分页查询和获取历史订单数据

10-36 我的订单

10-37 订单详情
	没有create_time 和 img？？？？？

10-38 小程序部分开场白与新建小程序项目

1.如何处理服务器传递给我们的数据
2.小程序API灵活应用
3.理解前后端分离

10-3九 新建小程序首页和小程序中的mvc

10-40 使用ES6构建小程序面对对象的JS代码以及访问服务器API获取数据

10-41 异步回调与箭头函数

11-5 构建请求基类

11-6 请求基类的应用

11-7 使用数据绑定将数据绑定在UI上

11-8 商品主题UI和数据加载

11-九 wxif的应用

11-10小程序模版的分析与应用

11-11 全局样式与复用思想
复用 
1.做前要布局 思考
2.重构

11-12页面跳转

11-13页面间传递和接收参数

11-14 windows 和 tabbar 的配置

11-15 主题页面和数据

11-16动态设置导航栏标题

11-17商品详情页面

11-18 商品详情页和picker组件

11-18 商品详情页和自定义选项卡切换思路

11-20 商品详情页面

11-21 商品分类页面

11-23 数据从服务器到前端交互的流程总结（重要)

11-24 商品分类页面

11-25拒绝向服务器频发发送请求

11-26面向对象思想编写购物车操作代码

12-3 商品详情页面动态响应用户加入购物车操作

12-4 购物车页面的开发
onLoad 执行一次
onShow 执行很多次

12-5 购物车页面开发二

12-6 购物车页面开发三----自定义checxbox 以及状态控制

12-7 购物车开发页面四

12-8 购物车开发页面五

12-九 购物车开发页面六

12-10 购物车开发页面七

12-11 这个问题你发现了吗

13-1 订单详情页面

13-2 添加用户收货地址

13-3 保存用户地址

13-4 增加api令牌验证接口

13-5 客户端 token类实现

13-6 重构Base下的 request方法

回调函数中 箭头函数 不会改变 this主体
success 会

13-7 在order页面加载和显示用户地址
13-8 在服务器编写获取用户地址接口

13-九 下单与支付
 直接支付 未下单
 我的订单里面支付 已下单、

 13-10
 支付后刷新订单详情页面

 13-14 修复订单快照下商品图片的问题

 13-15订单状态未修改成功原因 ----微信请求不到我们本地服务器

 13-16点击按钮返回订单详情页面

 13-17 获取用户信息

 13-18 显示用户收货地址

 13-1九 初步显示历史订单

 13-20 分页加载历史订单

 13-21 重构订单详情页面

 购物车 ---- 订单页面 缓存中加载
 购物车 下单 支付返回----订单页面 与服务器交互
 购物车 下单 支付 查看我的订单----订单页面 与服务器交互
 我的订单-----订单页面 与服务器交互

 13-22 在我的订单里进行支付

 13-23 避免重复刷新订单列表

 14-1 如何理解cms在架构中的位置

 	cms和小程序一样
 	也是客户端应用程序
 	通过API和服务器做交互

 14-2 访问CMS

 14-3 应用令牌获取接口 和 应用令牌的理解

 	token 不是针对某个具体的用户
 		是针对 cms本身的

 		cms如何控制自己的权限 是你自己的事情
 		api颁发的令牌是 全部用户的最高权限
 14-4 获取所有订单 分页

 14-5 微信模板消息介绍
 	发送微信模板消息 不是主动推送 而是被动响应

 	用户支付成功一次 可以向用户在7天内推送三次模版消息

 	提交表单       可以向用户在7天内推送一次模版消息

 CROS 简单请求 复杂请求？？？

 //php think optimize:schema
 //php think optimize:route

